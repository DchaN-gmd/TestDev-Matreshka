Начал разибрать проект

1.Начал с разбора абстрактого класса Abstract food place, в нем есть два абстрактных метода,
их можно преопределить: tryPlaceFood, который является булевым и он принимает себя объект
класса bool, и FreePlace. Видимо, первый пытается либо вложить еду, либо освободить место, но из-за принимания
в себя объект класса Food, скорее всего первое.

2.Далее класс AutoFoodFiller, он запечатан с помощью оператора sealed, хз зачем (P.s Понял, что это сообщает CLR, что ниже нет переопределния, что влияет на производительность).
В нем есть поле name, которое null по дефолту. Он содержит в себе список из AbstractPlaceFood, который в update через форыч пытатся пихнуть еду
через метод tryPlaceFood.

3.Решил сразу чекнуть класс Food (он тоже запечатан). Сразу видно enum FoodStatus состояний: raw, cooked, overcooked. Есть поле name и поле FoodStatus.
(P.s почему то везде public стоит, странная херня). Увидел конструктор принимающий имя и принимающий состояние еды, у него по дефолту стоит raw.
Есть метод CookStep со ситчом по капотом, в нем проверка на состояние, на данный момент, еды, видимо для обращения к нему и изменения состояния из-вне.

4.Следующий на очереди CookingTimer(запечатан), сразу прикололо то, что в нем создан еще один класс TimerSpriteSet в котором лежат спрайты background и foreground (по дефолту null).
  В нем есть экземпляр класса FoodPlace (def=null), переменные background и foreground, но уже типа Image(хз как это влияет).
  Определены два экземпляры класса TimerSpriteSet: normal и overcook, хз как это работает и зачем.
 Появилась еще более странная херня, то-ли метод, то-ли поле, но понятно то, что в нем есть сетер, он чекает на null и проверяет это background или foreground,
а дальше (резко понял что там учавствуют Image'ы back и fore которые были объявлены вне этогой ъерни, значит они принимают картинки и переводят их в sprite), переводит их в sprite
присваивают значение value.Backgorund, который описан в TimerSpriteSet и устнавливает нативный размер(выравнивает по пикселям, вроде как улучшает картинку).
В Awake идет проверка на Place, значит пока не передадут place нихера не заработает, если place есть то идет подписка на событие FoodPlaceUpdated, 
который лежит в самом place, метод который подписывается OnFoodPlaceUpdated, он делает проверку IsCooking который в place, после чего, видимо включает таймер через
gameObject.setActive, затем в CurSet запихивает значение от проверки состояние еды и впихивает либо Normal, либо Overcook, но хз на что это влияет. А в else вырубает таймер.В OnDestroy 
идет отписка. В старте вызывает OnFoodPlaceFood. В update, проверяет place на null, если не нулл, то foreground (который видимо является заполнением), заполняет шкалу.

5. Наначал чекать FoodPlace(ОН НАСЛЕДУЕТСЯ ОТ AbstractFoodPlace). Есть три переменных, одно булевое Cook, видимо влаг приготовлен или нет, остальные два связанны со временем CookTime 
и OvercookTime. Так же событие FoodPlaceUpdated, думаю для обновление места для еды. Есть переменная таймер (приватная, лол). 
Какого то хрена экземпляр класса Food сделали полем хз как это работает, но забавно. Еще есть флаг IsFree, который осовобождает curFood(делает его null).
По методам, есть метод TimerNormalized, в котором идут проверки есть ли еда, готовится ли она, ну короче делает че-то с таймером.
В update есть выход через if, где идет проверки IsFree(видимо он при true является пустым, не совсем понял, как он работает), !Cook(не готовится), !IsCooking(Не готовка).
Если проходит в if, то выход через return. Если выхода нет, то идет счет таймера, далее через case идет проверка на состояние готовки (понял, что есть проверка overcookTime,
она отвечает за то, что еду можно ложить как на доску так и на сковородку, а значит чтобы не шел таймер все обнуляется если не выставлен overcookTime), механика проста, чисто
чек таймера и выставленного времени CookTime и OvercookTime а далее вызов степа из Food затем вызов события FoodPlaceUpdated.
Пошел к переопределенному методу tryPlaceFood(принимает в себя Food): есть выход через флаг isFree. CurFood берет food, затем идет проверка на Cook (хз зачем) и 
что статус еды не overcooked, если все true, то isCooking = true. Вызывается событие FoodPlaceUpdated и идет возврат true.
Далее полетел к методу ExtractFood (видимо извлекает еду из класса, короче отдает образец food куда-то) внутри обнуляет curFood, но перед этим передает его в обраец res, 
вызывает событие FoodPlaceUpdated и возвращает res.
Ласт метод (наканецта) переопределенный метод FreePlace, обнуляет все к чертовой матери (curFood,timer, Iscooking =false) и вызваает собыитие

6. Дальше на промываение костей подъехал FoodPlacer (какая-то хуйня), в нем есть лист из AbstractFoodPlace и поле FoodName, ну и переопределенный метод tryPlaceFood,
который внутри перебирает список и пытается передать Food через TryPlaceFood (ебанинина какая-то), возвращает пустое значение, а еще помечен UsedImplicitly. Метод странный что пиздец.

7. И опять большая херня, на очереде FoodPresenter (видимо отдавать еду) (Пошел смотреть FoodVisualazer) Так, понял, что тут тема с перемещением еды по столу, если она где-то включается,
то она выключается на сковороде (вроде на ней, т.к только на сковородках этот скрипт). Скрипт с приколом, понятно, что он отвечает за отоброжение еды если ее перемещают.(ВОЗМОЖНО ЧИСТО НА СКОВОРОДЕ)

8. FoodVisualazer. Так ну тут опять лист, только уже из геймобджектов, звать auxObject (что-то вспомогательное), ну и про поле имя не забыли. Метод один SetEnabled, 
принимает в себя бул yesno (нэйминг на уровне). Тут тоже какой-то пиздец полный происходит. Вырубает какой-то gameobject и через обращение к листу делает вроде форыч,
но что творится внутри хуй его знает. Хотя понял, он тупо врубает объекты еды, на сковороде и тд.

9. Пока что влез к FoodServer на чай. Сразу увидел что без FoodPlace эта херня не работает. Так, тут дело в мелочах которые я не все понимаю, но суть в том, что он пытается вроде как
отдать еду, то-ли ее обработать, но тут пока что хз, но ясно то, что он в конце освобождает место. А так чекает приготовлена ли еда или место !свободно
Потом создает экземпляр заказа и чекает существует ли такой(возможно первый в списке), ну и вроде идет чек возможно ли отдать заказ (TryServeOrder). Если все норм,
то осовобождает место и возвращает true. ТАК, ТУТ ФИШКА В ТОМ,ЧТО ОН ЧИСТО ЧЕКАЕТ ЕСТЬ ЛИ ТАКОЙ ЗАКАЗ, ПРИГОТОВЛЕНА ЛИ ЕДА И СЕРВЕРУЕТ ЕЕ ПОСЛЕ ЧЕГО ОСОВОБОЖДАЕТ МЕСТО.

10. FoodTransfer. Не может без FoodPlace. Флаг OnlyTransferCooked (хз), и лист AbstractFoodPlace, вроде как-то перемещает еду по столу, но пока не ясно, так ли... Так до-конца не понял
так что надо будет чекнуть чуть позже.

11. А вот и вкусненькое FoodTrasher (ТУТ ФУНКИЦИЯ ПО ТЗ) Ну собственно принимает в себя FoodPlace, и таймер хз зачем, нужно реализовать удалене по двойному тапу. Пока на этом все.

12. GroupFoodServer. Лежит на напитках, делает список FoodServer, через форыч перебирает элементы и пытается их отдать, а после освободить место. (С скриптами типа Food... покончено)

13. Order. В нем есть вложенный класс OrderFood с конструкторо для принятия имени и Needs (типо, что надо вроде как). Далее создал один лист с вложанными заказами
который потом передается в коллекцию. Ну и есть конструктор самого класса который принимает имя и коллекцию заказов.

14.OrderPlaces (очень большой :-( )(Наследуется от AbstractFoodPlace) Есть лист FoodPlace и стринговый лист CurOrder(?), событие CurOrderUpdated и лист Order который в старте берет из OrderController лист.
 CanAddFood чекает есть ли на досточке этот элемент еды, если нет, то добавляет. UpdatePossibleOrders удалаят элемент который уже есть на доске. 
TryPlaceFood пытается добавить элемент на досточки, если на всех досточках есть этот элемент, то выход.

15. OrderPresenter по идее через метод-подписчик возвращает список элементов заказа (ПЕРЕСМОТРЕТЬ НА СВЕЖУЮ ГОЛОВУ).

16. OrderVisualazer врубает еду на досточках.

17. OrderController. Есть конструктор инициализации, и он вроде как сингалтон. В инит достает xml файл с прописанными заказами (НАДО БУДЕТ ДОПИСАТЬ ЗДЕСЬ ХОТ-ДОГИ).
ParseOrder разбирает заказ на элементы еды. FindOrder находит эелемент еды и его возвращает (хз зачем).

18. OrderServer. Освобождает место на досточке(там по цепочке пытается отдать заказ). (Скрипты Order кончились)

19. Customer принимает в себя изображаения, время ожидания, лист CustomerOrderPlaces, лист Order, таймер, isActive и какой-то патч. 
WaitTime возвращает, скорее всего, оставшееся время ожидания.
IsComplete. Возвращает tr/fl есть ли еще заказы.
В update проверяет и обновляет таймер, если время вышло, то освобождает поситителя.
SetRandomSprite говорит само за себя.
Init вроде как обновляет поситителя (хз ЧЕКНУТЬ ПОЗЖЕ)
ServeOrder вроде как отдает заказ, но лучше еще раз посмотреть позже.

20. CustomerOrderPlace. Init принимает в себя заказ, включает его. Complete вырубает.

21. CustomerPlace. Создает и удаляет поситителя.

22. CustomerContoller .......